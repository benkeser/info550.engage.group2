base::`+`(e1, e2)
}
}
## Define model parameters:
m<- 50
n1 = 3
n2 = 2
rho = 0.4
sigma2 = 1^2
alpha = 0.05
## A sequence of effect sizes (slope) to calculate power for
effs = seq(0, 1, by = 0.01)
## Set up design matrix
X0 <- c(rep(1, 250))
X1 <- c(rep(c(0,0,0), each=25), rep(c(0,0,1), each=25), rep(c(1,0), each=25), rep(c(1,1), each=25))
X <- cbind(X0,X1)
## Set up covariance matrix
R01 = diag(n1)*(1-rho) + matrix(rep(1,n1*n1), ncol=n1)*rho
R02 = diag(n2)*(1-rho) + matrix(rep(1,n2*n2), ncol=n2)*rho
V1 = sigma*kronecker(diag(1,m), R01)
power =  pnorm ( qnorm (alpha/2) + abs(effs)/SE[2])
'+' <- function(e1, e2) {
if (is.character(e1) | is.character(e2)) {
paste0(e1, e2)
} else {
base::`+`(e1, e2)
}
}
# Define model parameters:
m1 <- 50
n1 <- 3
n2 <- 2
rho <- 0.4
sigma <- 1
alpha <- 0.05
beta <- 0.2
## A sequence of effect sizes (slope) to calculate power for
effs = seq(0, 1, by = 0.01)
# construct the design matrix
# the data structure is like: every participants have 3 period and each period is assigned as 0 if placebo or washout, 1 if treatment
x0 <- rep(1, m1*n1+m1*n2)
x1 <- c(rep(c(0,0,0), 25), rep(c(0,0,1), 25), rep(c(1,0), 25), rep(c(1,1), 25))
X <- cbind(x0, x1)
# ## Set up covariance matrix
R01 = diag(n1)*(1-rho) + matrix(rep(1,n1*n1), ncol=n1)*rho
R02 = diag(n2)*(1-rho) + matrix(rep(1,n2*n2), ncol=n2)*rho
V1 = sigma*kronecker(diag(1,m1), R01)
V2 = sigma*kronecker(diag(1,m1), R02)
V = as.matrix(Matrix::bdiag(V1, V2))
##Covariance of beta_hat and standard errors
VCOV = solve (t(X)%*%solve(V)%*%X)
SE = sqrt (diag (VCOV))
power =  pnorm ( qnorm (alpha/2) + abs(effs)/SE[2])
plot (power~effs, type = "l", lwd = 3, xlab = "Effect Size (Slope)")
abline(h = 0.8, col = 2, lty= 3)
beta1 <- (qnorm(0.2)+qnorm(1-alpha/2))*SE**2
aa <- cbind(effs,power)
power =  pnorm ( qnorm (alpha/2) + abs(effs)/SE[2])
plot (power~effs, type = "l", lwd = 3, xlab = "Effect Size (Slope)")
abline(h = 0.8, col = 2, lty= 3)
mde <- (qnorm(1-alpha/2) + qnorm(1-beta)) * SE[2]
aa <- cbind(effs,power)
'+' <- function(e1, e2) {
if (is.character(e1) | is.character(e2)) {
paste0(e1, e2)
} else {
base::`+`(e1, e2)
}
}
# Define model parameters:
m <- 50
n1 <- 3
n2 <- 2
rho <- 0.4
sigma <- 1
alpha <- 0.05
beta <- 0.2
#A sequence of effect sizes (slope) to calculate power for
effs = seq(0, 1, by = 0.01)
#construct the design matrix
x0 <- rep(1, m*n1+m*n2)
x1 <- c(rep(c(0,0,0), 25), rep(c(0,0,1), 25), rep(c(1,0), 25), rep(c(1,1), 25))
X <- cbind(x0, x1)
#Set up covariance matrix
R01 = diag(n1)*(1-rho) + matrix(rep(1,n1*n1), ncol=n1)*rho
R02 = diag(n2)*(1-rho) + matrix(rep(1,n2*n2), ncol=n2)*rho
V1 = sigma*kronecker(diag(1,m), R01)
V2 = sigma*kronecker(diag(1,m), R02)
V = as.matrix(Matrix::bdiag(V1, V2))
#Covariance of beta_hat and standard errors
VCOV = solve (t(X)%*%solve(V)%*%X)
SE = sqrt (diag (VCOV))
'+' <- function(e1, e2) {
if (is.character(e1) | is.character(e2)) {
paste0(e1, e2)
} else {
base::`+`(e1, e2)
}
}
# Define model parameters:
m <- 50
n1 <- 3
n2 <- 2
rho <- 0.4
sigma <- 1
alpha <- 0.05
beta <- 0.2
#A sequence of effect sizes (slope) to calculate power for
effs = seq(0, 1, by = 0.01)
#construct the design matrix
x0 <- rep(1, m*n1+m*n2)
x1 <- c(rep(c(0,0,0), 25), rep(c(0,0,1), 25), rep(c(1,0), 25), rep(c(1,1), 25))
X <- cbind(x0, x1)
#Set up covariance matrix
R01 = diag(n1)*(1-rho) + matrix(rep(1,n1*n1), ncol=n1)*rho
R02 = diag(n2)*(1-rho) + matrix(rep(1,n2*n2), ncol=n2)*rho
V1 = sigma*kronecker(diag(1,m), R01)
V2 = sigma*kronecker(diag(1,m), R02)
V = as.matrix(Matrix::bdiag(V1, V2))
#Covariance of beta_hat and standard errors
VCOV = solve (t(X)%*%solve(V)%*%X)
SE = sqrt (diag (VCOV))
power =  pnorm ( qnorm (alpha/2) + abs(effs)/SE[2])
plot (power~effs, type = "l", lwd = 3, xlab = "Effect Size (Slope)")
abline(h = 0.8, col = 2, lty= 3)
#MDE
mde <- (qnorm(1-alpha/2) + qnorm(1-beta)) * SE[2]
aa <- cbind(effs,power)
# Define model parameters:
m <- 50
n1 <- 3
n2 <- 2
rho <- 0.4
sigma <- 1
alpha <- 0.05
beta <- 0.2
#A sequence of effect sizes (slope) to calculate power for
effs = seq(0, 1, by = 0.01)
#construct the design matrix
x0 <- rep(1, 250)
x1 <- c(rep(c(0,0,0), 25), rep(c(0,0,1), 25), rep(c(1,0), 25), rep(c(1,1), 25))
X <- cbind(x0, x1)
#Set up covariance matrix
R01 = diag(n1)*(1-rho) + matrix(rep(1,n1*n1), ncol=n1)*rho
R02 = diag(n2)*(1-rho) + matrix(rep(1,n2*n2), ncol=n2)*rho
V1 = sigma*kronecker(diag(1,m), R01)
V2 = sigma*kronecker(diag(1,m), R02)
V = as.matrix(Matrix::bdiag(V1, V2))
#Covariance of beta_hat and standard errors
VCOV = solve (t(X)%*%solve(V)%*%X)
SE = sqrt (diag (VCOV))
power =  pnorm ( qnorm (alpha/2) + abs(effs)/SE[2])
plot (power~effs, type = "l", lwd = 3, xlab = "Effect Size (Slope)")
abline(h = 0.8, col = 2, lty= 3)
#MDE
mde <- (qnorm(1-alpha/2) + qnorm(1-beta)) * SE[2]
aa <- cbind(effs,power)
## Define model parameters:
m = 100
n = 3
rho = 0.4
sigma2 = 1^2
alpha = 0.05
beta <- 0.2
## A sequence of effect sizes (slope) to calculate power for
effs = seq(0, 1, by = 0.001)
#design matrix
x0 <- rep(1, m*n)
x1 <- c(rep(c(0,0,0), 25), rep(c(0,0,1), 25), rep(c(1,0,0), 25), rep(c(1,0,1), 25))
X <- cbind(x0, x1)
## Set up covariance matrix
R0 = diag(n)*(1-rho) + matrix(rep(1,n*n), ncol=n)*rho
V = sigma*kronecker(diag(1,m), R0)
##Covariance of beta_hat and standard errors
VCOV = solve (t(X)%*%solve(V)%*%X)
SE = sqrt (diag (VCOV))
power =  pnorm ( qnorm (alpha/2) + abs(effs)/SE[2])
plot (power~effs, type = "l", lwd = 3, xlab = "Effect Size (Slope)")
abline(h = 0.8, col = 2, lty= 3)
#MDE
mde <- (qnorm(1-alpha/2) + qnorm(1-beta)) * SE[2]
aa <- cbind(effs,power)
View(aa)
# Define model parameters:
m <- 50
n1 <- 3
n2 <- 2
rho <- 0.4
sigma <- 1
alpha <- 0.05
beta <- 0.2
#A sequence of effect sizes (slope) to calculate power for
effs = seq(0, 1, by = 0.001)
#construct the design matrix
x0 <- rep(1, 250)
x1 <- c(rep(c(0,0,0), 25), rep(c(0,0,1), 25), rep(c(1,0), 25), rep(c(1,1), 25))
X2 <- c(rep(c(1,2,3), 25), rep(c(1,2,3), 25), rep(c(1,3), 25), rep(c(1,3), 25)) #period
X <- cbind(x0, x1, X2)
#Set up covariance matrix
R01 = diag(n1)*(1-rho) + matrix(rep(1,n1*n1), ncol=n1)*rho
R02 = diag(n2)*(1-rho) + matrix(rep(1,n2*n2), ncol=n2)*rho
V1 = sigma*kronecker(diag(1,m), R01)
V2 = sigma*kronecker(diag(1,m), R02)
V = as.matrix(Matrix::bdiag(V1, V2))
#Covariance of beta_hat and standard errors
VCOV = solve (t(X)%*%solve(V)%*%X)
SE = sqrt (diag (VCOV))
power =  pnorm ( qnorm (alpha/2) + abs(effs)/SE[2])
plot (power~effs, type = "l", lwd = 3, xlab = "Effect Size (Slope)")
abline(h = 0.8, col = 2, lty= 3)
beta1 <- (qnorm(0.2)+qnorm(1-alpha/2))*sqrt(2*sigma2/(m*n)*(1+(n-1)*rho))
power =  pnorm ( qnorm (alpha/2) + abs(effs)/SE[2])
plot (power~effs, type = "l", lwd = 3, xlab = "Effect Size (Slope)")
abline(h = 0.8, col = 2, lty= 3)
#MDE
mde <- (qnorm(1-alpha/2) + qnorm(1-beta)) * SE[2]
aa <- cbind(effs,power)
# Define model parameters:
m1 <- 50
n1 <- 3
n2 <- 2
rho <- 0.4
sigma <- 1
alpha <- 0.05
beta <- 0.2
## A sequence of effect sizes (slope) to calculate power for
effs = seq(0, 1, by = 0.01)
# construct the design matrix
# the data structure is like: every participants have 3 period and each period is assigned as 0 if placebo or washout, 1 if treatment
x0 <- rep(1, m1*n1+m1*n2)
x1 <- c(rep(c(0,0,0), 25), rep(c(0,0,1), 25), rep(c(1,0), 25), rep(c(1,1), 25))
x2 <- c(rep(c(1,2,3), 50), rep(c(1,3), 50))
X <- cbind(x0, x1, x2)
# ## Set up covariance matrix
R01 = diag(n1)*(1-rho) + matrix(rep(1,n1*n1), ncol=n1)*rho
R02 = diag(n2)*(1-rho) + matrix(rep(1,n2*n2), ncol=n2)*rho
V1 = sigma*kronecker(diag(1,m1), R01)
V2 = sigma*kronecker(diag(1,m1), R02)
V = as.matrix(Matrix::bdiag(V1, V2))
##Covariance of beta_hat and standard errors
VCOV = solve (t(X)%*%solve(V)%*%X)
SE = sqrt (diag (VCOV))
# plot the power vs effect size
power <- pnorm ( qnorm (alpha/2) + abs(effs)/SE[2])
plot (power~effs, type = "l", lwd = 3, xlab = "Effect Size", ylab = "Power")
abline(h = 0.8, col = 2, lty= 3)
# and calculate the minimum detectable effect
mde <- (qnorm(1-alpha/2) + qnorm(1-beta)) * SE[2]
'+' <- function(e1, e2) {
if (is.character(e1) | is.character(e2)) {
paste0(e1, e2)
} else {
base::`+`(e1, e2)
}
}
# Define model parameters:
m1 <- 50
n1 <- 3
n2 <- 2
rho <- 0.4
sigma <- 1
alpha <- 0.05
beta <- 0.2
## A sequence of effect sizes (slope) to calculate power for
effs = seq(0, 1, by = 0.01)
# construct the design matrix
# the data structure is like: every participants have 3 period and each period is assigned as 0 if placebo or washout, 1 if treatment
x0 <- rep(1, m1*n1+m1*n2)
x1 <- c(rep(c(0,0,0), 25), rep(c(0,0,1), 25), rep(c(1,0), 25), rep(c(1,1), 25))
X <- cbind(x0, x1)
# ## Set up covariance matrix
R01 = diag(n1)*(1-rho) + matrix(rep(1,n1*n1), ncol=n1)*rho
R02 = diag(n2)*(1-rho) + matrix(rep(1,n2*n2), ncol=n2)*rho
V1 = sigma*kronecker(diag(1,m1), R01)
V2 = sigma*kronecker(diag(1,m1), R02)
V = as.matrix(Matrix::bdiag(V1, V2))
##Covariance of beta_hat and standard errors
VCOV = solve (t(X)%*%solve(V)%*%X)
SE = sqrt (diag (VCOV))
# plot the power vs effect size
power <- pnorm ( qnorm (alpha/2) + abs(effs)/SE[2])
plot (power~effs, type = "l", lwd = 3, xlab = "Effect Size", ylab = "Power")
abline(h = 0.8, col = 2, lty= 3)
# and calculate the minimum detectable effect
mde <- (qnorm(1-alpha/2) + qnorm(1-beta)) * SE[2]
## Define model parameters:
m = 100
n = 3
rho = 0.4
sigma2 = 1^2
alpha = 0.05
beta <- 0.2
## A sequence of effect sizes (slope) to calculate power for
effs = seq(0, 1, by = 0.001)
#design matrix
x0 <- rep(1, m*n)
x1 <- c(rep(c(0,0,0), 25), rep(c(0,0,1), 25), rep(c(1,0,0), 25), rep(c(1,0,1), 25))
X <- cbind(x0, x1)
## Set up covariance matrix
R0 = diag(n)*(1-rho) + matrix(rep(1,n*n), ncol=n)*rho
V = sigma*kronecker(diag(1,m), R0)
##Covariance of beta_hat and standard errors
VCOV = solve (t(X)%*%solve(V)%*%X)
SE = sqrt (diag (VCOV))
## Define model parameters:
m = 100
n = 3
rho = 0.4
sigma2 = 1^2
alpha = 0.05
beta <- 0.2
## A sequence of effect sizes (slope) to calculate power for
effs = seq(0, 1, by = 0.001)
#design matrix
x0 <- rep(1, m*n)
x1 <- c(rep(c(0,0,0), 25), rep(c(0,0,1), 25), rep(c(1,0,0), 25), rep(c(1,0,1), 25))
X <- cbind(x0, x1)
## Set up covariance matrix
R0 = diag(n)*(1-rho) + matrix(rep(1,n*n), ncol=n)*rho
V = sigma*kronecker(diag(1,m), R0)
##Covariance of beta_hat and standard errors
VCOV = solve (t(X)%*%solve(V)%*%X)
SE = sqrt (diag (VCOV))
power =  pnorm ( qnorm (alpha/2) + abs(effs)/SE[2])
plot (power~effs, type = "l", lwd = 3, xlab = "Effect Size (Slope)")
abline(h = 0.8, col = 2, lty= 3)
#MDE
mde <- (qnorm(1-alpha/2) + qnorm(1-beta)) * SE[2]
aa <- cbind(effs,power)
knitr::opts_chunk$set(echo = TRUE)
## Define model parameters:
m = 100
n = 3
rho = 0.4
sigma2 = 1^2
alpha = 0.05
beta <- 0.2
## A sequence of effect sizes (slope) to calculate power for
effs = seq(0, 1, by = 0.001)
#design matrix
x0 <- rep(1, m*n)
x1 <- c(rep(c(0,0,0), 25), rep(c(0,0,1), 25), rep(c(1,0,0), 25), rep(c(1,0,1), 25))
X <- cbind(x0, x1)
## Set up covariance matrix
R0 = diag(n)*(1-rho) + matrix(rep(1,n*n), ncol=n)*rho
V = sigma*kronecker(diag(1,m), R0)
##Covariance of beta_hat and standard errors
VCOV = solve (t(X)%*%solve(V)%*%X)
SE = sqrt (diag (VCOV))
power =  pnorm ( qnorm (alpha/2) + abs(effs)/SE[2])
plot (power~effs, type = "l", lwd = 3, xlab = "Effect Size (Slope)")
abline(h = 0.8, col = 2, lty= 3)
#MDE
mde <- (qnorm(1-alpha/2) + qnorm(1-beta)) * SE[2]
aa <- cbind(effs,power)
# Define model parameters:
m <- 50
n1 <- 3
n2 <- 2
rho <- 0.4
sigma <- 1
alpha <- 0.05
beta <- 0.2
#A sequence of effect sizes (slope) to calculate power for
effs = seq(0, 1, by = 0.001)
#construct the design matrix
x0 <- rep(1, 250)
x1 <- c(rep(c(0,0,0), 25), rep(c(0,0,1), 25), rep(c(1,0), 25), rep(c(1,1), 25))
X <- cbind(x0, x1)
#Set up covariance matrix
R01 = diag(n1)*(1-rho) + matrix(rep(1,n1*n1), ncol=n1)*rho
R02 = diag(n2)*(1-rho) + matrix(rep(1,n2*n2), ncol=n2)*rho
V1 = sigma*kronecker(diag(1,m), R01)
V2 = sigma*kronecker(diag(1,m), R02)
V = as.matrix(Matrix::bdiag(V1, V2))
#Covariance of beta_hat and standard errors
VCOV = solve (t(X)%*%solve(V)%*%X)
SE = sqrt (diag (VCOV))
power =  pnorm ( qnorm (alpha/2) + abs(effs)/SE[2])
plot (power~effs, type = "l", lwd = 3, xlab = "Effect Size (Slope)")
abline(h = 0.8, col = 2, lty= 3)
#MDE
mde <- (qnorm(1-alpha/2) + qnorm(1-beta)) * SE[2]
aa <- cbind(effs,power)
# Define model parameters:
m <- 50
n1 <- 3
n2 <- 2
rho <- 0.4
sigma <- 1
alpha <- 0.05
beta <- 0.2
#A sequence of effect sizes (slope) to calculate power for
effs = seq(0, 1, by = 0.001)
#construct the design matrix
x0 <- rep(1, 250)
x1 <- c(rep(c(0,0,0), 25), rep(c(0,0,1), 25), rep(c(1,0), 25), rep(c(1,1), 25))
X2 <- c(rep(c(1,2,3), 25), rep(c(1,2,3), 25), rep(c(1,3), 25), rep(c(1,3), 25)) #period
X <- cbind(x0, x1, X2)
#Set up covariance matrix
R01 = diag(n1)*(1-rho) + matrix(rep(1,n1*n1), ncol=n1)*rho
R02 = diag(n2)*(1-rho) + matrix(rep(1,n2*n2), ncol=n2)*rho
V1 = sigma*kronecker(diag(1,m), R01)
V2 = sigma*kronecker(diag(1,m), R02)
V = as.matrix(Matrix::bdiag(V1, V2))
#Covariance of beta_hat and standard errors
VCOV = solve (t(X)%*%solve(V)%*%X)
SE = sqrt (diag (VCOV))
power =  pnorm ( qnorm (alpha/2) + abs(effs)/SE[2])
plot (power~effs, type = "l", lwd = 3, xlab = "Effect Size (Slope)")
abline(h = 0.8, col = 2, lty= 3)
#MDE
mde <- (qnorm(1-alpha/2) + qnorm(1-beta)) * SE[2]
aa <- cbind(effs,power)
knitr::opts_chunk$set(echo = TRUE)
#load  baseline, 3month, 6month data into v0, v1, v2
load("D:/22fall/Capstone/ALS/Analysis Data/base.RData")
v0 <- data
load("D:/22fall/Capstone/ALS/Analysis Data/v1.RData")
v1 <- data
load("D:/22fall/Capstone/ALS/Analysis Data/v2.RData")
v2 <- data
rm(data)
#subtract numeric ID of paired patients at baseline
# load library
library(stringr)
# prepare regular expression
regexp <- "[[:digit:]]+"
# process string
v0$IDs_num <- as.numeric(str_extract(v0$IDs, regexp))
#count paired participants
library(dplyr)
c0 <- v0%>%
group_by(IDs_num)%>%
count()%>%
filter(n==2)
#subtract numeric ID of paired patients at 3 months
# process string
v1$IDs_num <- as.numeric(str_extract(v1$IDs, regexp))
#count paired participants
library(dplyr)
c1 <- v1%>%
group_by(IDs_num)%>%
count()%>%
filter(n==2)
#subtract numeric ID of paired patients at 3 months
# process string
v2$IDs_num <- as.numeric(str_extract(v2$IDs, regexp))
#count paired participants
library(dplyr)
c2 <- v2%>%
group_by(IDs_num)%>%
count()%>%
filter(n==2)
#merge v0 and v1
data1 <- merge(v0,v1,by.x=c("IDs"),by.y=c("IDs"))
View(c0)
toString(c0$IDs_num)
toString(c1$IDs_num)
knitr::opts_chunk$set(echo = TRUE)
#load  baseline, 3month, 6month data into v0, v1, v2
load("D:/22fall/Capstone/ALS/Analysis Data/base.RData")
v0 <- data
load("D:/22fall/Capstone/ALS/Analysis Data/v1.RData")
v1 <- data
load("D:/22fall/Capstone/ALS/Analysis Data/v2.RData")
v2 <- data
rm(data)
#subtract numeric ID of paired patients at baseline
# load library
library(stringr)
# prepare regular expression
regexp <- "[[:digit:]]+"
# process string
v0$IDs_num <- as.numeric(str_extract(v0$IDs, regexp))
#count paired participants
library(dplyr)
c0 <- v0%>%
group_by(IDs_num)%>%
count()%>%
filter(n==2)
#subtract numeric ID of paired patients at 3 months
# process string
v1$IDs_num <- as.numeric(str_extract(v1$IDs, regexp))
#count paired participants
library(dplyr)
c1 <- v1%>%
group_by(IDs_num)%>%
count()%>%
filter(n==2)
#subtract numeric ID of paired patients at 3 months
# process string
v2$IDs_num <- as.numeric(str_extract(v2$IDs, regexp))
#count paired participants
library(dplyr)
c2 <- v2%>%
group_by(IDs_num)%>%
count()%>%
filter(n==2)
#merge v0 and v1
data1 <- merge(v0,v1,by.x=c("IDs"),by.y=c("IDs"))
View(v0)
setwd("D:\22fall")
setwd("D:\22fall\INFO550\W13\hiv_project_files-1")
setwd("D:/22fall/INFO550/W13/hiv_project_files-1")
renv::init()
setwd("D:/22fall/INFO550/W13/grp/info550.engage.group2")
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
here::i_am('engage_report.Rmd')
table1 <- readRDS(
here::here('output/table1.rds')
)
